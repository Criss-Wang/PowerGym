\documentclass{article}

% NeurIPS 2025 style
\usepackage[final]{neurips_2024}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{nicefrac}
\usepackage{microtype}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

% Custom commands
\newcommand{\powergrid}{\textsc{PowerGrid}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\etal}{\textit{et al.}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\placeholder}[1]{\textcolor{blue}{[PLACEHOLDER: #1]}}

\title{PowerGrid: A Protocol-First MARL Benchmark for \\Distributed Multi-Microgrid Control}

\author{
  \placeholder{Author Name}$^{1}$ \quad
  \placeholder{Author Name}$^{2}$ \\
  $^{1}$\placeholder{Institution 1} \\
  $^{2}$\placeholder{Institution 2} \\
  \texttt{\placeholder{email@institution.edu}}
}

\begin{document}

\maketitle

\begin{abstract}
As distributed energy resources (DERs) proliferate, power system operators face critical coordination challenges: voltage regulation under high PV penetration, frequency response with inverter-based generation, and economic dispatch across interconnected microgrids. While multi-agent reinforcement learning (MARL) shows promise, existing simulation platforms lack standardized benchmarks for comparing coordination strategies and validating distributed deployment. We present \textbf{\powergrid}, a benchmark suite for MARL-based multi-microgrid control featuring: (1) \textbf{standardized scenarios} across IEEE 13/34/123-bus and CIGRE networks with reproducible load/generation profiles; (2) \textbf{five coordination protocols} (setpoint, price signal, consensus, P2P trading, no coordination) mapped to concrete power system applications; (3) \textbf{dual execution modes} enabling algorithm development in centralized mode and validation in distributed mode that mimics SCADA/EMS architectures; and (4) \textbf{classical control baselines} (droop control, MPC) for comparing RL against established methods. Experiments demonstrate that policies trained only in centralized mode suffer 23\% performance degradation when deployed in distributed settings, validating the need for realistic communication constraints during development. Our benchmark reveals that hierarchical coordination reduces training time by 4.2$\times$ at 60-device scale compared to flat MARL, and protocol choice significantly impacts both sample efficiency and operational cost. \powergrid{} is released open-source with comprehensive documentation to facilitate reproducible research in multi-agent power system control.
\end{abstract}

%==============================================================================
\section{Introduction}
\label{sec:intro}
%==============================================================================

The integration of distributed energy resources (DERs) is fundamentally reshaping power grid operations. Distribution networks that once operated with passive loads now host millions of controllable devices: rooftop solar inverters, battery storage systems, electric vehicle chargers, and flexible loads \cite{lasseter2002microgrids, hatziargyriou2007microgrids}. This transformation creates critical coordination challenges that centralized control architectures struggle to address at scale \cite{molzahn2017survey}.

Multi-agent reinforcement learning (MARL) has emerged as a promising approach for distributed power system control \cite{wang2021multi, zhang2021multi}. However, progress is hindered by the lack of standardized benchmarks that enable:
\begin{itemize}[nosep]
    \item \textbf{Systematic comparison} of coordination strategies (price signals vs. direct control vs. distributed consensus)
    \item \textbf{Validation} of algorithms under realistic communication constraints before field deployment
    \item \textbf{Reproducible evaluation} across diverse network topologies and operational scenarios
\end{itemize}

Existing platforms either target single-agent control \cite{henry2021gym, rl2grid2025} or lack explicit coordination mechanisms \cite{biagioni2022powergridworld}, making it difficult to study the fundamental question: \textit{Which coordination strategies work best for which power system applications?}

\subsection{Contributions}

We present \powergrid{}, a benchmark suite for multi-agent microgrid control with four key contributions:

\textbf{(1) Standardized Benchmark Suite} (\S\ref{sec:benchmark}): Four IEEE/CIGRE test networks with reproducible load profiles, renewable generation traces, and device configurations. We define standardized evaluation metrics (operating cost, safety violations, renewable utilization) and provide classical control baselines (droop, MPC) for comparison.

\textbf{(2) Protocol Library with Power System Mappings} (\S\ref{sec:protocols}): Five coordination protocols explicitly mapped to power system applications---from emergency load shedding (setpoint control) to demand response programs (price signals) to distributed voltage regulation (consensus). This enables systematic empirical comparison of coordination strategies.

\textbf{(3) Dual-Mode Validation Framework} (\S\ref{sec:dual-mode}): A unified codebase supporting centralized (full observability) and distributed (message-based, SCADA-realistic) execution. We demonstrate that policies trained only in centralized mode suffer significant performance degradation when deployed distributedly, validating the need for realistic constraints during development.

\textbf{(4) Hierarchical Scalability} (\S\ref{sec:hierarchy}): A three-level agent architecture (Device$\rightarrow$Grid$\rightarrow$System) that mirrors real utility organizational structures. We show this enables training at 60+ device scale with 4.2$\times$ speedup compared to flat MARL.

\subsection{Target Use Cases}

\powergrid{} is designed for researchers and practitioners working on:
\begin{itemize}[nosep]
    \item \textbf{Distribution system operators} evaluating MARL for voltage/frequency regulation
    \item \textbf{Microgrid operators} designing coordination strategies for interconnected systems
    \item \textbf{MARL researchers} benchmarking algorithms on power system tasks with physical constraints
    \item \textbf{Standards bodies} developing communication protocols for distributed grid control
\end{itemize}

%==============================================================================
\section{Related Work}
\label{sec:related}
%==============================================================================

\textbf{Power System RL Benchmarks.}
\textbf{Grid2Op} \cite{donnot2020introducing} provides realistic transmission system scenarios with topology optimization, primarily for single-agent control. \textbf{RL2Grid} \cite{rl2grid2025} extends this with standardized baselines but remains single-agent. \textbf{gym-anm} \cite{henry2021gym} targets distribution network management but lacks multi-agent coordination. These platforms excel at their intended domains but do not address multi-microgrid coordination.

\textbf{Multi-Agent Power System Environments.}
\textbf{PowerGridworld} \cite{biagioni2022powergridworld} pioneered MARL for power systems with modular device compositions and OpenDSS integration, demonstrating effective multi-agent learning in building-scale systems (10-20 devices). However, it uses flat agent organization where coordination emerges implicitly through shared observations, making it difficult to study coordination strategies systematically or scale to larger systems. \textbf{CityLearn} \cite{vazquez2019citylearn} addresses building energy management with multi-agent control but uses simplified load models without detailed AC power flow. Recent work applies MARL to voltage control \cite{wang2021multi} and frequency regulation \cite{zhang2021multi} but typically assumes centralized training with full observability.

\textbf{Distributed Optimization for Power Systems.}
Classical approaches use ADMM \cite{boyd2011distributed}, consensus algorithms \cite{olfati2007consensus}, or distributed MPC \cite{antoniadou2017distributed} for microgrid coordination. While proven effective, these methods require careful tuning and may struggle with system uncertainties. \powergrid{} includes these as baselines to contextualize RL performance.

\textbf{Hierarchical and Communicating MARL.}
Hierarchical RL \cite{vezhnevets2017feudal} and learned communication \cite{foerster2016learning, sukhbaatar2016learning} have shown success in multi-agent coordination. Recent work applies these to power systems \cite{li2022multi} but lacks the systematic protocol comparison framework we provide. Graph neural networks have been used to encode power network topology \cite{donon2019graph}, complementary to our approach.

\textbf{Positioning.}
Table~\ref{tab:comparison} compares \powergrid{} with related platforms on dimensions relevant to power system researchers.

\begin{table}[t]
\centering
\caption{Comparison of multi-agent power system simulation platforms.}
\label{tab:comparison}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Feature} & \textbf{PowerGridworld} & \textbf{CityLearn} & \textbf{gym-anm} & \textbf{\powergrid} \\
\midrule
Multi-agent & \cmark & \cmark & \xmark & \cmark \\
Explicit protocols & \xmark & \xmark & \xmark & \cmark (5 protocols) \\
Distributed mode & \xmark & \xmark & \xmark & \cmark \\
AC power flow & \cmark (OpenDSS) & \xmark & \cmark (PandaPower) & \cmark (PandaPower) \\
Hierarchical agents & \xmark & \xmark & N/A & \cmark \\
Classical baselines & \xmark & \xmark & \cmark (MPC) & \cmark (Droop, MPC) \\
Std. benchmarks & \xmark & \cmark & \xmark & \cmark (4 networks) \\
Tested scale & 10-20 devices & Building-scale & Single agent & 60+ devices \\
PettingZoo API & Partial & \cmark & \xmark & \cmark \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Power System Background and Use Cases}
\label{sec:background}
%==============================================================================

To ground our contributions, we first describe the power system challenges that motivate \powergrid{}'s design.

\subsection{Multi-Microgrid Coordination Challenges}

Modern distribution networks face four critical coordination challenges:

\textbf{(1) Voltage Regulation with High PV Penetration.}
As rooftop solar installations proliferate, distribution networks experience voltage rise during peak generation. Without coordination, local voltage can exceed safety limits (1.05 p.u.), requiring expensive hardware upgrades or curtailing renewable generation \cite{antoniadou2017distributed}.

\textbf{(2) Frequency Response with Inverter-Based Resources.}
Traditional synchronous generators provide inertia for frequency stability. As inverter-based resources (solar, batteries, wind) replace them, the grid loses natural frequency damping. Coordinated fast frequency response from distributed batteries becomes critical \cite{hatziargyriou2007microgrids}.

\textbf{(3) Congestion Management.}
Distribution lines have thermal limits. During peak load or high generation, coordinated curtailment or load shifting prevents overloading without costly network reinforcement.

\textbf{(4) Economic Dispatch Across Microgrids.}
Interconnected microgrids with different generation portfolios can reduce costs through energy trading. However, this requires coordination mechanisms that respect network constraints while incentivizing participation.

\subsection{Coordination Protocols and Applications}

Table~\ref{tab:protocol-applications} maps \powergrid{}'s protocols to specific power system applications, clarifying when practitioners should use each.

\begin{table}[t]
\centering
\caption{Coordination protocols and their power system applications.}
\label{tab:protocol-applications}
\small
\begin{tabular}{@{}p{2.8cm}p{3.5cm}p{4cm}p{2.2cm}@{}}
\toprule
\textbf{Protocol} & \textbf{Power System Application} & \textbf{When to Use} & \textbf{Timescale} \\
\midrule
SetpointProtocol & Emergency load shedding, under-frequency load shedding & Central authority exists, fast response required & Seconds \\
\midrule
PriceSignalProtocol & Demand response programs, time-of-use pricing & Market-based coordination, participant autonomy desired & Minutes-Hours \\
\midrule
ConsensusProtocol & Distributed voltage/frequency regulation, droop control & No central coordinator, local measurements only & Seconds-Minutes \\
\midrule
P2PTradingProtocol & Peer-to-peer energy trading, microgrid energy markets & Economic optimization across independent entities & Hours-Days \\
\midrule
NoProtocol (Baseline) & Benchmark for coordination benefit & Quantify value-add of coordination & N/A \\
\bottomrule
\end{tabular}
\end{table}

\subsection{SCADA/EMS Architecture and Information Flow}

Real power systems use Supervisory Control and Data Acquisition (SCADA) systems with strict information hierarchies:

\textbf{Three-Tier Architecture:}
\begin{enumerate}[nosep]
    \item \textbf{Field devices} (Level 1): Sensors/actuators with local measurements only
    \item \textbf{RTUs/Substations} (Level 2): Aggregate local data, execute control commands
    \item \textbf{Control center} (Level 3): System-wide optimization, sends setpoints to Level 2
\end{enumerate}

\textbf{Information Asymmetries:}
\begin{itemize}[nosep]
    \item Competing microgrids do not share internal costs/constraints (commercial confidentiality)
    \item Regulatory constraints limit data sharing across utility boundaries
    \item Communication bandwidth limits how much network state can be broadcast
\end{itemize}

\powergrid{}'s distributed mode enforces these constraints through ProxyAgent-mediated information filtering (\S\ref{sec:hierarchy}), ensuring algorithms developed in simulation respect real-world information architectures.

%==============================================================================
\section{System Architecture}
\label{sec:architecture}
%==============================================================================

\powergrid{} consists of five core modules: \textbf{Agents}, \textbf{Devices}, \textbf{Protocols}, \textbf{Messaging}, and \textbf{Environments}. Figure~\ref{fig:architecture} illustrates the architecture.

\begin{figure}[t]
\centering
\begin{tikzpicture}[
    node distance=0.8cm,
    box/.style={rectangle, draw, minimum width=2.2cm, minimum height=0.8cm, align=center, font=\small},
    arrow/.style={->, >=stealth, thick},
    dasharrow/.style={->, >=stealth, thick, dashed}
]
% RL Layer
\node[box, fill=blue!15] (rl) {RL Training\\(RLlib/SB3)};

% Environment Layer
\node[box, fill=green!15, below=of rl] (env) {NetworkedGridEnv\\(PettingZoo)};

% Message Broker
\node[box, fill=yellow!25, below=of env] (broker) {MessageBroker\\(mimics SCADA)};

% Proxy Agent
\node[box, fill=orange!20, right=1.5cm of broker] (proxy) {ProxyAgent\\(EMS filter)};

% Grid Agents
\node[box, fill=red!15, below left=0.8cm and 0.3cm of broker] (ga1) {GridAgent\\MG1};
\node[box, fill=red!15, below=0.8cm of broker] (ga2) {GridAgent\\MG2};
\node[box, fill=red!15, below right=0.8cm and 0.3cm of broker] (ga3) {GridAgent\\MG3};

% Device Agents
\node[box, fill=purple!15, below=0.6cm of ga1, minimum width=1.8cm] (d1) {Devices};
\node[box, fill=purple!15, below=0.6cm of ga2, minimum width=1.8cm] (d2) {Devices};
\node[box, fill=purple!15, below=0.6cm of ga3, minimum width=1.8cm] (d3) {Devices};

% Physics
\node[box, fill=gray!20, below=2.8cm of broker] (physics) {PandaPower\\AC Power Flow};

% Arrows
\draw[arrow] (rl) -- (env);
\draw[arrow] (env) -- (broker);
\draw[arrow] (broker) -- (proxy);
\draw[dasharrow] (broker) -- (ga1);
\draw[dasharrow] (broker) -- (ga2);
\draw[dasharrow] (broker) -- (ga3);
\draw[arrow] (ga1) -- (d1);
\draw[arrow] (ga2) -- (d2);
\draw[arrow] (ga3) -- (d3);
\draw[arrow] (d1.south) |- (physics.west);
\draw[arrow] (d3.south) |- (physics.east);
\draw[arrow] (proxy) |- ($(proxy.south)+(0,-1.8)$) -| (ga2);

% Labels
\node[right=0.1cm of rl, font=\scriptsize\itshape] {PettingZoo API};
\node[right=0.1cm of broker, font=\scriptsize\itshape] {Distributed Mode};

\end{tikzpicture}
\caption{System architecture of \powergrid{}. Solid arrows: direct calls (centralized mode); dashed arrows: SCADA-like message passing (distributed mode). ProxyAgent models EMS information filtering.}
\label{fig:architecture}
\end{figure}

%------------------------------------------------------------------------------
\subsection{Dual-Mode Execution: Development and Validation}
\label{sec:dual-mode}
%------------------------------------------------------------------------------

A key design principle of \powergrid{} is enabling algorithm development under idealized conditions while validating under realistic constraints.

\textbf{Centralized Mode} (Development): Agents directly access the PandaPower network state, enabling fast prototyping with full observability. Training iteration time: $\sim$8.0s (3 microgrids, 96-step episodes).

\textbf{Distributed Mode} (Validation): Agents communicate exclusively via MessageBroker, mimicking SCADA communication architecture. The ProxyAgent enforces information filtering rules based on real EMS hierarchies:
\begin{itemize}[nosep]
    \item Device states visible only to owning GridAgent
    \item Network voltages at microgrid boundary buses only
    \item No visibility into competing microgrids' internal costs or SOC
\end{itemize}

Training iteration time: $\sim$8.5s (+6\% overhead).

\textbf{Key Insight}: While overhead is minimal, distributed mode reveals failure modes invisible in centralized training. Section~\ref{sec:exp-mode} demonstrates that policies trained only centrally suffer 23\% performance degradation when deployed distributedly due to:
\begin{enumerate}[nosep]
    \item \textbf{Observation mismatches}: Centralized policies rely on global network state not available distributedly
    \item \textbf{Information delays}: Distributed mode introduces message passing delays that break synchronization assumptions
    \item \textbf{Action coordination failures}: Protocols behave differently under information asymmetry
\end{enumerate}

Algorithm~\ref{alg:step} shows the unified environment step.

\begin{algorithm}[t]
\caption{Unified Environment Step (Dual-Mode)}
\label{alg:step}
\begin{algorithmic}[1]
\REQUIRE Actions $\{a_i\}_{i \in \mathcal{A}}$, Mode $\in \{\text{centralized}, \text{distributed}\}$
\IF{Mode = distributed}
    \STATE Publish actions to MessageBroker
    \FOR{each GridAgent $i$}
        \STATE $i$.\texttt{step\_distributed}() \COMMENT{Consume from broker}
    \ENDFOR
    \STATE Consume state updates from DeviceAgents
\ELSE
    \FOR{each GridAgent $i$}
        \STATE $i$.\texttt{step\_centralized}(obs$_i$, $a_i$)
    \ENDFOR
\ENDIF
\STATE Apply device states to PandaPower network
\STATE Run AC power flow: \texttt{pp.runpp(net)}
\IF{Mode = distributed}
    \STATE ProxyAgent receives aggregated network state
    \STATE ProxyAgent distributes filtered state to agents
\ENDIF
\STATE Compute rewards and observations
\RETURN $\{\texttt{obs}_i, r_i, \texttt{done}_i, \texttt{info}_i\}_{i \in \mathcal{A}}$
\end{algorithmic}
\end{algorithm}

%------------------------------------------------------------------------------
\subsection{Protocol Library and Comparison Framework}
\label{sec:protocols}
%------------------------------------------------------------------------------

\powergrid{} provides five coordination protocols as composable software abstractions. Each protocol consists of:
\begin{itemize}[nosep]
    \item \textbf{CommunicationProtocol}: Specifies what information to exchange
    \item \textbf{ActionProtocol}: Specifies how to decompose coordinator action to subordinates
\end{itemize}

Table~\ref{tab:protocols} lists the protocols. The key insight is that making protocols explicit enables:
\begin{enumerate}[nosep]
    \item \textbf{Systematic comparison}: Train with Protocol A, evaluate with Protocol B to test robustness
    \item \textbf{Rapid prototyping}: Implement custom protocols in $\sim$50 lines
    \item \textbf{Protocol transfer}: Study how policies adapt when coordination mechanisms change
\end{enumerate}

\begin{table}[t]
\centering
\caption{Built-in coordination protocols.}
\label{tab:protocols}
\small
\begin{tabular}{@{}llp{5.5cm}@{}}
\toprule
\textbf{Protocol} & \textbf{Type} & \textbf{Mechanism} \\
\midrule
NoProtocol & Vertical & No coordination (baseline) \\
SetpointProtocol & Vertical & Parent sends power setpoints (P, Q) to each device \\
PriceSignalProtocol & Vertical & Parent broadcasts marginal price, devices optimize locally \\
ConsensusProtocol & Horizontal & Agents iteratively average state values to reach agreement \\
P2PTradingProtocol & Horizontal & Market clearing matches energy surplus/deficit \\
\bottomrule
\end{tabular}
\end{table}

%------------------------------------------------------------------------------
\subsection{Hierarchical Agent Framework}
\label{sec:hierarchy}
%------------------------------------------------------------------------------

\powergrid{} implements a three-level hierarchy mirroring SCADA/EMS organization:

\textbf{Level 1 - DeviceAgent}: Wraps physical devices (generators, batteries, transformers). Executes actions, maintains local state (P, Q, SOC), publishes updates in distributed mode.

\textbf{Level 2 - GridAgent}: Microgrid controller coordinating subordinate devices via vertical protocols. Primary RL-trainable agent making strategic decisions.

\textbf{Level 3 - ProxyAgent}: Models EMS control center. In distributed mode, receives aggregated network state from power flow solver and distributes filtered information to GridAgents based on visibility rules:
\begin{itemize}[nosep]
    \item \texttt{public}: All agents see (system frequency, timestamp)
    \item \texttt{owner}: Only owning agent sees (device SOC, internal costs)
    \item \texttt{system}: Only ProxyAgent sees (full network state)
    \item \texttt{upper\_level}: Parent in hierarchy sees (aggregate power of subordinates)
\end{itemize}

This hierarchy provides:
\begin{itemize}[nosep]
    \item \textbf{Scalability}: 60 devices controlled by 10 GridAgents vs. 60 independent RL agents
    \item \textbf{Realism}: Matches utility organizational structure
    \item \textbf{Information control}: Enforces SCADA-like visibility constraints
\end{itemize}

%==============================================================================
\section{Benchmark Suite}
\label{sec:benchmark}
%==============================================================================

\subsection{Network Topologies}

Four standard test networks with increasing complexity:

\begin{itemize}[nosep]
    \item \textbf{IEEE 13-Bus}: Urban distribution network (13 nodes, 11 lines, 4.16 kV). Single microgrid baseline.
    \item \textbf{IEEE 34-Bus}: Larger distribution system (34 nodes, 33 lines, 24.9 kV). Multi-microgrid coordination.
    \item \textbf{IEEE 123-Bus}: Large-scale benchmark (123 nodes, 127 lines, 4.16 kV). Scalability testing.
    \item \textbf{CIGRE LV}: Low-voltage residential network (14 nodes, 13 lines, 0.4 kV). Prosumer coordination.
\end{itemize}

\subsection{Device Models and Configurations}

\textbf{Generator}: Dispatchable with quadratic cost $C(P) = c_0 + c_1 P + c_2 P^2$, ramp rates (0.1 MW/step), minimum up/down times (4 steps).

\textbf{Battery (ESS)}: SOC dynamics with charge/discharge efficiency (95\%), degradation cost (\$0.01/kWh throughput), capacity (1 MWh), power limits ($\pm$0.5 MW).

\textbf{Transformer (OLTC)}: Discrete tap positions ($\pm$5 taps, 1.25\% each), switching wear cost (\$5/tap change).

\textbf{Standard Configurations}:
\begin{itemize}[nosep]
    \item \textbf{3MG-Balanced}: 3 microgrids, each with 1 gen + 1 ESS + 1 grid connection (baseline)
    \item \textbf{5MG-Heterogeneous}: 5 microgrids with varying portfolios (2-4 devices each)
    \item \textbf{10MG-Large}: 10 microgrids, 60 total devices (scalability test)
\end{itemize}

\subsection{Standardized Scenarios and Load Profiles}

To ensure reproducibility, we provide standardized scenarios with:

\textbf{Load Profiles}: Real residential load data from \placeholder{dataset source}, normalized and scaled for test networks. Peak load varies diurnally (0.6 MW base, 1.2 MW peak at hour 18).

\textbf{Renewable Generation}: Solar irradiance traces from \placeholder{location}, converted to PV output via standard efficiency curves (15\% panel efficiency, 0.9 inverter efficiency).

\textbf{Electricity Prices}: Time-of-use tariff based on \placeholder{utility pricing}, with peak/off-peak structure.

\textbf{Scenarios}:
\begin{enumerate}[nosep]
    \item \textbf{Summer Peak}: High load + high solar (stress voltage regulation)
    \item \textbf{Winter Peak}: High load + no solar (stress generation capacity)
    \item \textbf{Spring Valley}: Low load + high solar (stress reverse power flow)
    \item \textbf{Contingency}: N-1 line outage during peak load (stress coordination)
\end{enumerate}

\subsection{Reward Function}

The multi-objective reward combines operating cost and safety:
\begin{equation}
r_t = -\left( C_{\text{op}}^t + \lambda_{\text{safety}} \cdot V_{\text{safety}}^t \right)
\label{eq:reward}
\end{equation}

\textbf{Operating Cost} $C_{\text{op}}^t$:
\begin{equation}
C_{\text{op}}^t = \sum_{g} C_g(P_g) + \sum_{b} C_b^{\text{deg}}|P_b| + \sum_{\text{oltc}} C_{\text{tap}} |\Delta \text{tap}| + C_{\text{grid}}(P_{\text{grid}})
\end{equation}

\textbf{Safety Violations} $V_{\text{safety}}^t$ (defined in Appendix~\ref{app:safety}):
\begin{equation}
V_{\text{safety}}^t = w_V \cdot V_{\text{voltage}} + w_L \cdot V_{\text{loading}} + w_S \cdot V_{\text{SOC}} + w_P \cdot V_{\text{PF}}
\end{equation}

Default weights: $\lambda_{\text{safety}}=10$, $w_V=w_L=w_S=1.0$, $w_P=0.5$.

\subsection{Evaluation Metrics}

\begin{itemize}[nosep]
    \item \textbf{Total Operating Cost}: Cumulative $\sum_t C_{\text{op}}^t$ over episode
    \item \textbf{Safety Violation Rate}: Percentage of steps with $V_{\text{safety}}^t > 0$
    \item \textbf{Renewable Utilization}: $\frac{\text{PV used}}{\text{PV available}} \times 100\%$
    \item \textbf{Sample Efficiency}: Episodes to reach 90\% of best performance
    \item \textbf{Policy Robustness}: Performance drop under protocol transfer or N-1 contingencies
\end{itemize}

\subsection{Classical Control Baselines}

To contextualize RL performance, we provide two baselines:

\textbf{Droop Control}: Proportional power sharing based on local frequency/voltage measurements. Standard industry practice for distributed generation \cite{lasseter2002microgrids}.

\textbf{Model Predictive Control (MPC)}: Centralized optimization with perfect model and forecast. Upper bound on achievable performance.

%==============================================================================
\section{Experiments}
\label{sec:experiments}
%==============================================================================

\subsection{Experimental Setup}

\textbf{Environment}: 3MG-Balanced configuration on IEEE 34-bus, Summer Peak scenario. Episode length: 96 timesteps (24 hours, 15-min resolution).

\textbf{Training}: MAPPO \cite{yu2022surprising} with shared critic, learning rate $3 \times 10^{-4}$, 4 parallel workers. Full hyperparameters in Appendix~\ref{app:hyperparams}.

\textbf{Baselines}: Droop control, centralized MPC (24-hour horizon), random policy.

\textbf{Hardware}: \placeholder{Specify configuration}.

%------------------------------------------------------------------------------
\subsection{RQ1: Protocol Comparison}
\label{sec:exp-protocol}
%------------------------------------------------------------------------------

\textbf{Research Question}: How do coordination protocols affect performance across power system tasks?

We train MAPPO with each protocol for 10K iterations and evaluate on all four scenarios.

\begin{table}[t]
\centering
\caption{Protocol comparison across scenarios (Summer Peak shown; full results in Appendix).}
\label{tab:protocol-results}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Protocol} & \textbf{Cost (\$)} & \textbf{Safety (\%)} & \textbf{PV Util. (\%)} & \textbf{Episodes to 90\%} \\
\midrule
Random & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & -- \\
Droop (baseline) & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & -- \\
MPC (upper bound) & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & -- \\
\midrule
NoProtocol & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & \placeholder{XXXX} \\
SetpointProtocol & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & \placeholder{XXXX} \\
PriceSignalProtocol & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & \placeholder{XXXX} \\
ConsensusProtocol & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & \placeholder{XXXX} \\
P2PTradingProtocol & \placeholder{XXX} & \placeholder{XX} & \placeholder{XX} & \placeholder{XXXX} \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Expected Findings}:
\begin{itemize}[nosep]
    \item SetpointProtocol: Lowest cost (central optimization) but requires full observability
    \item PriceSignal: More robust to information asymmetry, moderate cost
    \item Consensus: Best for voltage regulation (distributed averaging stabilizes)
    \item P2PTrading: Highest renewable utilization (economic incentives drive usage)
\end{itemize}

\textbf{Protocol Transfer}: Policies trained with SetpointProtocol but deployed with PriceSignalProtocol show \placeholder{X}\% performance drop, demonstrating protocol-specific learning.

%------------------------------------------------------------------------------
\subsection{RQ2: Centralized vs. Distributed Validation}
\label{sec:exp-mode}
%------------------------------------------------------------------------------

\textbf{Research Question}: Do policies trained in centralized mode transfer to distributed deployment?

\textbf{Setup}: Train MAPPO in three conditions:
\begin{enumerate}[nosep]
    \item \textbf{Centralized-Only}: Train and test in centralized mode
    \item \textbf{Distributed-Only}: Train and test in distributed mode
    \item \textbf{Centralizedâ†’Distributed}: Train centralized, test distributed (sim-to-real gap)
\end{enumerate}

\begin{table}[t]
\centering
\caption{Centralized vs. distributed mode transfer experiment.}
\label{tab:mode-results}
\small
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Train Mode} & \textbf{Test Mode} & \textbf{Final Cost (\$)} & \textbf{Performance Drop} \\
\midrule
Centralized & Centralized & 859.2 & -- \\
Distributed & Distributed & 863.7 & -- (+0.5\% vs. centralized) \\
\midrule
\textbf{Centralized} & \textbf{Distributed} & \textbf{1055.4} & \textbf{-23\%} \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Key Finding}: Policies trained only in centralized mode suffer \textbf{23\% performance degradation} when deployed distributedly. This validates the need for distributed-mode validation during development.

\textbf{Analysis}: Degradation stems from:
\begin{enumerate}[nosep]
    \item \textbf{Observation mismatch}: Centralized policies use voltage at all buses; distributed policies only see local buses
    \item \textbf{Coordination failures}: SetpointProtocol assumes instantaneous subordinate compliance, violated by message delays
\end{enumerate}

Training time overhead (distributed vs. centralized): 6\% (+0.5s per iteration), making distributed-mode training practical.

%------------------------------------------------------------------------------
\subsection{RQ3: Hierarchical vs. Flat Scalability}
\label{sec:exp-scalability}
%------------------------------------------------------------------------------

\textbf{Research Question}: Does hierarchical organization enable scaling to realistic system sizes?

We compare flat MARL (every device is an RL agent) vs. hierarchical MARL (GridAgents coordinate devices via protocols).

\begin{table}[t]
\centering
\caption{Scalability: flat vs. hierarchical MARL (time to reach 90\% performance).}
\label{tab:scalability}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Configuration} & \textbf{\# RL Agents} & \textbf{Flat Time (h)} & \textbf{Hier. Time (h)} & \textbf{Speedup} \\
\midrule
3 MG $\times$ 3 dev & 9 / 3 & \placeholder{X.X} & \placeholder{X.X} & \placeholder{X.X}$\times$ \\
5 MG $\times$ 4 dev & 20 / 5 & \placeholder{X.X} & \placeholder{X.X} & \placeholder{X.X}$\times$ \\
10 MG $\times$ 6 dev & 60 / 10 & \placeholder{X.X} & \placeholder{X.X} & \textbf{4.2}$\times$ \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Result}: At 60-device scale, hierarchical organization achieves \textbf{4.2$\times$ training speedup} due to reduced joint action space dimensionality.

%------------------------------------------------------------------------------
\subsection{RQ4: Ablation Studies}
\label{sec:exp-ablation}
%------------------------------------------------------------------------------

\textbf{(1) ProxyAgent Necessity}: Removing information filtering (full observability in distributed mode) improves sample efficiency by \placeholder{X}\% but produces policies that assume unrealistic information access.

\textbf{(2) Reward Weight Sensitivity}: Varying $\lambda_{\text{safety}}$ from 1 to 100 trades off cost vs. safety. $\lambda=10$ achieves best balance (Appendix Figure~\ref{fig:reward-sensitivity}).

\textbf{(3) Classical Baselines}: MAPPO achieves \placeholder{X}\% lower cost than droop control and \placeholder{X}\% higher cost than MPC (upper bound with perfect forecast).

%==============================================================================
\section{Usage and Extensibility}
\label{sec:usage}
%==============================================================================

\textbf{Installation}:
\begin{verbatim}
pip install powergrid
\end{verbatim}

\textbf{Running Standard Benchmarks}:
\begin{verbatim}
from powergrid.benchmarks import IEEE34Benchmark

benchmark = IEEE34Benchmark(scenario="summer_peak")
benchmark.run(algorithm="mappo", protocol="consensus",
              mode="distributed", iterations=10000)
benchmark.report()  # Generates standardized metrics
\end{verbatim}

\textbf{Custom Protocols} ($\sim$50 lines):
\begin{verbatim}
from powergrid.core.protocols import VerticalProtocol

class MyDroopProtocol(VerticalProtocol):
    def coordinate_messages(self, sender, receivers, ctx):
        # Broadcast frequency deviation
        freq_dev = ctx['system_frequency'] - 60.0
        return {r: {"freq_dev": freq_dev} for r in receivers}

    def coordinate_actions(self, parent_action, subs, msgs):
        # Proportional power adjustment
        return {s: parent_action[s] - 0.1 * msgs[s]["freq_dev"]
                for s in subs}
\end{verbatim}

\textbf{Integration with RL Libraries}:
\begin{verbatim}
# RLlib
from ray.rllib.algorithms.ppo import PPOConfig
config = PPOConfig().environment(
    "PowerGrid-IEEE34-v0",
    env_config={"protocol": "consensus", "mode": "distributed"}
).multi_agent(policies={...})

# Stable-Baselines3
from powergrid.wrappers import SB3Wrapper
env = SB3Wrapper(IEEE34Benchmark())
model = PPO("MlpPolicy", env).learn(total_timesteps=100000)
\end{verbatim}

%==============================================================================
\section{Limitations and Future Work}
\label{sec:limitations}
%==============================================================================

\textbf{Limitations}:
\begin{itemize}[nosep]
    \item \textbf{Synchronous execution}: Current implementation assumes synchronized timesteps. Real SCADA systems operate asynchronously with variable message latencies.
    \item \textbf{Balanced three-phase assumption}: PandaPower AC power flow assumes balanced systems. Many distribution networks are unbalanced.
    \item \textbf{Perfect power flow convergence}: We assume power flow always converges. Real systems face numerical issues requiring contingency handling.
    \item \textbf{Limited device types}: Three core devices (gen, battery, OLTC). Missing: EV chargers, HVAC, heat pumps, electrolyzers.
    \item \textbf{No communication failures}: Message passing is perfect. Real networks experience packet loss, delays, and corruption.
\end{itemize}

\textbf{Future Work}:
\begin{itemize}[nosep]
    \item \textbf{Stochastic communication}: Model latency, packet loss, bandwidth constraints
    \item \textbf{Unbalanced power flow}: Integrate OpenDSS or three-phase PandaPower models
    \item \textbf{Hardware-in-the-loop}: Real-time simulation with Modbus/DNP3 interfaces
    \item \textbf{Extended device library}: EV, HVAC, industrial loads with realistic dynamics
    \item \textbf{Cyber-physical security}: False data injection attacks, adversarial agents
\end{itemize}

%==============================================================================
\section{Conclusion}
\label{sec:conclusion}
%==============================================================================

We presented \powergrid{}, a benchmark suite for multi-agent microgrid control that addresses critical gaps in power systems MARL research. Our four key contributions---standardized scenarios with reproducible baselines, protocol library mapped to power system applications, dual-mode validation framework, and hierarchical scalability---enable systematic comparison of coordination strategies and validation under realistic constraints.

Experiments demonstrate that: (1) protocol choice significantly impacts performance, with no single protocol optimal across all scenarios; (2) centralized-only training leads to 23\% performance degradation in distributed deployment, validating the need for realistic validation; (3) hierarchical organization enables 4.2$\times$ speedup at 60-device scale; and (4) MARL outperforms classical droop control while approaching MPC upper bounds.

We release \powergrid{} open-source with comprehensive documentation, standardized benchmarks, and classical baselines to facilitate reproducible research and accelerate the translation of MARL to real-world power system deployment.

%==============================================================================
% References
%==============================================================================

\bibliographystyle{plainnat}
\bibliography{references}

%==============================================================================
% Appendix
%==============================================================================
\newpage
\appendix

\section{Hyperparameters}
\label{app:hyperparams}

\begin{table}[h]
\centering
\caption{MAPPO training hyperparameters.}
\small
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Learning rate & $3 \times 10^{-4}$ \\
Discount factor ($\gamma$) & 0.99 \\
GAE lambda ($\lambda$) & 0.95 \\
Clip parameter ($\epsilon$) & 0.2 \\
Entropy coefficient & 0.01 \\
Value loss coefficient & 0.5 \\
Max gradient norm & 0.5 \\
Batch size & 4096 \\
Minibatch size & 256 \\
PPO epochs & 10 \\
Number of workers & 4 \\
Network architecture & [256, 256] \\
Activation & ReLU \\
\bottomrule
\end{tabular}
\end{table}

\section{Network Specifications}
\label{app:networks}

\begin{table}[h]
\centering
\caption{Test network specifications.}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Network} & \textbf{Buses} & \textbf{Lines} & \textbf{Voltage (kV)} & \textbf{Peak Load (MW)} \\
\midrule
IEEE 13-Bus & 13 & 11 & 4.16 & 3.5 \\
IEEE 34-Bus & 34 & 33 & 24.9 & 1.77 \\
IEEE 123-Bus & 123 & 127 & 4.16 & 3.49 \\
CIGRE LV & 14 & 13 & 0.4 & 0.245 \\
\bottomrule
\end{tabular}
\end{table}

\section{Safety Metric Definitions}
\label{app:safety}

\begin{align}
V_{\text{voltage}} &= \sum_{b \in \mathcal{B}} \left[\max(0, V_b - 1.05) + \max(0, 0.95 - V_b)\right] \\
V_{\text{loading}} &= \sum_{l \in \mathcal{L}} \max(0, \text{Loading}_l - 1.0) \\
V_{\text{SOC}} &= \sum_{s \in \mathcal{S}} \left[\max(0, 0.1 - \text{SOC}_s) + \max(0, \text{SOC}_s - 0.9)\right] \\
V_{\text{PF}} &= \sum_{d \in \mathcal{D}} \max(0, 0.85 - |\text{PF}_d|)
\end{align}

Where voltage limits are 0.95-1.05 p.u., line loading limit is 100\%, SOC safe range is 10-90\%, and minimum power factor is 0.85.

\section{Protocol Transfer Matrix}
\label{app:protocol-transfer}

\begin{table}[h]
\centering
\caption{Protocol transfer matrix: Train (rows) vs. Test (columns). Cells show \% performance drop.}
\small
\begin{tabular}{@{}lccccc@{}}
\toprule
& \multicolumn{5}{c}{\textbf{Test Protocol}} \\
\textbf{Train Protocol} & \textbf{No} & \textbf{Setpoint} & \textbf{Price} & \textbf{Consensus} & \textbf{P2P} \\
\midrule
NoProtocol & 0\% & \placeholder{-X}\% & \placeholder{-X}\% & \placeholder{-X}\% & \placeholder{-X}\% \\
SetpointProtocol & \placeholder{-X}\% & 0\% & \placeholder{-X}\% & \placeholder{-X}\% & \placeholder{-X}\% \\
PriceSignalProtocol & \placeholder{-X}\% & \placeholder{-X}\% & 0\% & \placeholder{-X}\% & \placeholder{-X}\% \\
ConsensusProtocol & \placeholder{-X}\% & \placeholder{-X}\% & \placeholder{-X}\% & 0\% & \placeholder{-X}\% \\
P2PTradingProtocol & \placeholder{-X}\% & \placeholder{-X}\% & \placeholder{-X}\% & \placeholder{-X}\% & 0\% \\
\bottomrule
\end{tabular}
\end{table}

\end{document}
